---
title: GraphQL 기본 개념 살펴보기
date: "2026-01-09T15:53:01.284Z"
description: "GraphQL이 무엇이고 왜 사용하는지, 키마와 타입, 쿼리, 뮤테이션, 리졸버 등을 다루어봅니다."
categories: ["GraphQL"]
tags: ["GraphQL"]
featuredImage: "./graphql_featured_img_1.svg"
draft: false
slug: "grqphql/graphql-basic-concepts-overview/"
---

# 들어가며 
Gatsby로 블로그를 운영하며 GraphQL을 가볍게 접해본 후, 그 독특한 방식이 호기심이 자극되어서 깊이 있게 공부를 시작했습니다. **쿼리를 통해 필요한 데이터만 골라 가져오는 방식**이 과연 REST API보다 어떤 점이 좋을지 궁금했고, 공부할수록 GraphQL은 활용성이 높은 기술이라는 것을 느꼈습니다. 이번 포스트에서는 GraphQL의 핵심 개념을 살펴보겠습니다

# 왜 GraphQL 이 탄생했을까?
서론에서 언급했듯이, GraphQL은 기존 **REST API의 구조적 한계를 극복하기 위해 탄생**했습니다. 서비스가 복잡해질수록 REST 방식은 데이터를 주고받는 과정에서 비효율성이 커지는데, 대표적으로 두 가지 문제가 발생합니다.

1. **오버페칭(Over-fetching)**: 필요한 것보다 더 많이 받음 클라이언트에서 사용자 이름만 필요한 상황임에도 불구하고, 서버가 정의한 엔드포인트에 따라 사용자의 주소, 연락처, 가입일 등 불필요한 정보까지 모두 내려받는 현상입니다. 이는 네트워크 대역폭을 낭비하고 모바일 환경에서 성능 저하의 원인이 됩니다.

2. **언더페칭(Under-fetching)**: 필요한 것보다 적게 받아 여러 번 요청함 하나의 화면을 구성하기 위해 여러 개의 엔드포인트를 호출해야 하는 상황입니다. 예를 들어 게시글 내용과 작성자 정보, 댓글 목록을 가져오기 위해 각각 `/posts`, `/users`, `/comments`로 세 번의 요청을 보내야 합니다. 이 과정에서 언더페칭과 더불어 각 API 응답마다 원치 않는 데이터까지 섞여 들어오는 오버페칭이 동시에 발생하기도 합니다.

**페이스북의 고민에서 부터 시작**  
이러한 문제는 서비스 규모가 커질수록 치명적이었습니다. 2012년 당시, 페이스북은 모바일 앱으로의 전환 과정에서 성능 문제에 직면했습니다. 뉴스피드처럼 복잡하고 다양한 데이터가 얽혀 있는 화면을 구현할 때, REST API로는 수많은 네트워크 요청과 데이터 낭비를 감당하기에는 한계가 있었습니다.

그러하여 페이스북 개발팀은 **"클라이언트가 직접 필요한 데이터의 구조를 정의하고, 단 한 번의 요청으로 원하는 데이터만 받을 수 없을까?"** 라는 질문을 던졌고, 그 해답으로 GraphQL이 탄생하였습니다.

# 핵심 개념 알아보기
추상적인 개념을 알아보기 전에 어떻게 동작하는지 예를 먼저 들어보겠습니다.
GraphQL 은 클라이언트가 내가 필요한 데이터가 무엇인지 요청하면 서버에서 알려주면 서버는 그에 맞는 데이터를 돌려주는 방식며, 이때 요청은 쿼리를 사용합니다.

예시를 보면
**블로그 포스트의 제목과 작성자 정보 요청(Query)**
```GraphQL
{
    post(id: 1) {
        title
        author {
            name
        }
    }
}
```
**서버의 응답**
```JSON
{
    "data": {
    "post": {
      "title": "그래프큐엘 시작하기",
      "author": { "name": "우디" }
    }
  }
}
```

예시와 같이 클라이언트가 작성한 모양 그대로 서버의 응답이 JSON 형태로 돌아옵니다.  
이러한 형태가 가능하려면 클라이언트는 서버가 "post 라는 데이터를 줄 수 있다", "id 를 입력하면 해당 id 에 대한 post 정보만 준다.", "post 에는 title, author 정보를 줄 수 있다." 등에 대한 정보를 알고 있다는 건데요.  
이것을 가능하게 하는 것이 **인트로스펙션(Introspection)**이라는 기능입니다. 쉽게 말해 서버가 클라이언트에게 '나는 이런 데이터를 줄 수 있어!'라고 자기소개를 하는 기능이죠. 그리고 이 자기소개서의 바탕이 되는 것이 바로 스키마와 타입입니다.

## 핵심1. 스키마와 타입(The Schema & Types)
스키마(Schema)는 GrahpQL 의 설계도이며 이 구성하는 것이 타입(Type) 입니다.  
먼저 타입부터 살펴보면

### 1. 타입
타입에는 두가지 종류가 있습니다.
- **스칼라 타입(Scalar Type)**: 가장 기본적인 데이터 조각입니다. 아래가 기본적으로 제공해주는 GrpahQL 스칼라 타입입니다.
    - String: 글자 (예: "우디")
    - Int: 정수 (예: 25)
    - Float: 실수 (예: 4.5)
    - Boolean: 참/거짓 (예: true)
    - ID: 고유 식별자 (객체를 식별할 때 쓰는 특수한 값)
    - 커스텀 스칼라(Custom Scalar): 사용자가 직접 생성한 스칼라 타입(날짜(Date)처럼 기본 타입 외에 특별히 정의한 타입)
- **객체 타입객체 타입(Object Type)**: 스칼라 타입들을 모아서 만든 '복합 데이터'입니다. 우리가 실제 서비스에서 다루는 **사용자(User)**나 **포스트(Post)** 같은 데이터 입니다.
```GraphQL
type Post {
    id: ID
    title: String    # 스칼라 타입
    content: String  # 스칼라 타입
    author: User     # 다른 객체 타입과의 관계
}
```

### 2. 스키마(Schema)
스키마는 위에서 만든 타입들을 한데 모으고, 클라이언트가 **어떤 행동(읽기, 쓰기 등)** 을 할 수 있는지 정의한 최종 문서입니다.  
스키마를 보면 이 서비스의 모든 것을 알 수 있습니다.

실제 스키마 파일은 보통 이런 식으로 구성됩니다. 마치 메뉴판의 '전체 카테고리'를 정해주는 것과 같아 보입니다.
```GraphQL
# 1. 데이터 타입 정의
type Post {
  id: ID
  title: String
  author: User
}

type User {
  id: ID
  name: String
}

# 2. 할 수 있는 행동(Query, Mutation 등) 정의
type Query {
  # "id를 주면 Post 하나를 줄게" 라는 약속
  post(id: ID): Post
}

type Mutation {
  # "제목을 주면 새로운 포스트를 만들고 그 결과를 보여줄게" 라는 약속
  createPost(title: String): Post
}
```

요약하자면 스키마는 **"어떤 타입의 데이터를(Type), 어떤 방식으로(Query/Mutation) 주고받을 것인가"** 에 대한 서버와 클라이언트의 표준이라고 할 수 있습니다.  
마치 REST API 에서 API 명세서(API Specification)를 정의한 것과 같습니다.

### 3. 스키마&타입 작성의 장점
- **안정성**: 정의되지 않은 엉뚱한 데이터를 요청하면 서버가 실행되기도 전에 "그건 없는 데이터야"라고 알려줄 수 있습니다.
- **협업 효율**: 프론트엔드 개발자는 스키마만 보고도 서버 개발자에게 물어볼 필요 없이 어떤 데이터를 받아올지 알 수 있습니다.

이제 스키마와 타입이 준비되었습니다. 그럼 이 스키마를 보고 실제로 데이터를 요청하는 방법인 **쿼리(Query)**에 대해 알아보겠습니다.

## 핵심2. 쿼리(Query) - 데이터 읽기
쿼리는 클라이언트가 서버에 데이터를 요청하는 방식입니다. REST API의 GET 요청과 비슷하지만, 훨씬 더 효율적입니다.

REST API는 서버가 정해준 데이터를 통째로 받아야 했지만, GraphQL 쿼리는 **내가 필요한 필드(Field)** 만 적어서 보냅니다.  
만약 블로그 포스트 `id:1` 의 제목, 작성자 이름을 가져오고 싶으면
- REST API: /posts/1 호출 시 제목, 본문, 작성일, 댓글 등 모든 데이터를 다 줍니다. (Overfetching)
- GraphQL: "제목이랑 작성자 이름만 줘!"라고 요청하면 딱 그 데이터만 줍니다.
```GraphQL
# "포스트 1번의 제목(title)과 작성자 이름(name)만 필요해"
{
    post(id: 1) {
        title
        author {
            name
        }
    }
}
```

위와 같이 스키마만 알면 어떤 데이터를 가져올지는 **클라이언트에게 주도권(Client-driven)'** 이 있습니다.

## 핵심3. 뮤테이션(Mutation) - 데이서 수정
뮤테이션은 REST API의 POST, PUT, DELETE를 하나로 합쳐놓은 것이라고 생각하면 쉽습니다.  
쿼리가 데이터를 가져오는 '읽기' 전용이라면, **뮤테이션(Mutation)**은 서버의 데이터를 변경하는 '쓰기' 전용 통로입니다. 이름 그대로 데이터에 '변화(Mutation)'를 주는 작업이죠.

### CUD(생성, 수정, 삭제) 작업 처리
뮤테이션을 사용하면 새로운 포스트를 만들거나(Create), 기존 내용을 고치거나(Update), 마음에 안 드는 데이터를 지우는(Delete) 작업을 할 수 있습니다.
```GraphQL
# 새로운 포스트를 작성하는 Mutation 예시
mutation {
    createPost(title: "뮤테이션 배우기", content: "생각보다 쉬워요") {
        id
        title
        createdAt
    }
}
```
위 코드는 createPost 로 title, content 를 전달해주고 성공 시 id, title, createdAt 를 전달 받습니다. 
```json
{
    "data": {
        "createPost": {
        "id": "101",
        "title": "뮤테이션 배우기",
        "createdAt": "2026-01-15T10:00:00Z"
        }
    }
}
```

//todo: input 에 대해선 간단하게 소개(type 과 차이점도 작성)

## 핵심 개념 3: 서브스크립션 (Subscription) - 실시간 데이터
> 웹소켓(WebSocket)을 통해 서버에서 클라이언트로 데이터를 푸시(Push)하는 방식 설명

## 루트 타입 (Root Types) 한눈에 보기

## 핵심4. 리졸버(Resolver) - 데이터 채우기
> 리졸버란 무엇인가, 쿼리가 들어왔을 때 실제 DB, API 에서 가져오는 실행 함수라는 것을 소개
> 유연성 강조: 다양한 데이터 소스를 하나로 묶을 수 있다

# GraphQL의 장단점 정리
> 장섬: 생산성 향상, 자기 문서화(Self-documentiong), 프론트 백엔드 분리 등..
> 단점/주의점: 캐싱 복잡성, 파일 업로드 처리, 초기 학습 곡선 등

# 마무리 및 다음 단계
> 모바일 클라이언트 개발자 입장에서의 감상
> 안드로이드, 스프링부트로 실습을 다음에 소개

```graphql
type User {
    name: String!
    email: String!
}
```
