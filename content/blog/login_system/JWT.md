---
title: "서명키 유출이 부른 비극: 쿠팡 해킹 사건으로 알아보는 JWT"
date: "2025-12-02T22:12:30.0001"
description: "전직 로그인 관리자가 서명키를 이용해 JWT 토큰을 위변조하고 사용자 정보를 탈취한 쿠팡 사태를 통해, JWT의 기본 동작 원리, 서명(Signature)의 역할 및 키 관리의 중요성을 알아봅니다."
categories: ["보안", "웹/백엔드", "인증"]
tags: ["JWT", "JSON Web Token", "서명키", "Signature Key", "정보보안", "인증", "쿠팡 해킹"]
draft: true
---

# 들어가며
>tbd: 배경 및 타임라인, 사건 개요: 이번 쿠팡 해킹 사태의 주요 경과(정보 유출 인지 시점, 수사 과정 등)를 간략히 정리. 
>tbd: 국회 청문회 등에서 밝혀진 핵심 발언('퇴사한 관리자가 서명키를 가지고 있었다', '인증에 JWT를 사용하고 있었다')을 제시하고, 이 발언들이 의미하는 기술적 위험성을 제기
> 글의 목표 제시: 이 사건을 통해 **JWT의 서명키(Secret Key)**가 무엇이며, 서명키 유출이 어떻게 대규모 정보 탈취로 이어질 수 있었는지 그 원리를 철저히 파헤쳐봅니다.

# JWT란 무엇이며, 왜 서명키가 중요한가?

## JWT의 정의 및 필요성
tbd: JWT가 등장하게 된 배경(Scale-out, Stateless)을 간략히 설명

## 토큰 기반 인증 vs 세션 기반 인증 (관리 주체 차이)
tbd: 세션: 서버가 상태(State)를 직접 관리(DB, 메모리).

## JWT 의 3단 구조
tbd: Header.Payload: 이 부분은 인코딩되었을 뿐, 누구나 쉽게 디코딩하여 내용을 볼 수 있음을 강조
tbd: Signature: 토큰이 위변조되지 않았음을 보장하는 유일한 장치이며, **서명키'** 를 통해서만 생성/검증됨을 강조.
tbd: JWT 토큰: 클라이언트가 토큰을 소지하며, 서버는 상태를 관리하지 않고 토큰의 유효성만 검증하는 차이점을 명확히 설명합니다. (🔑 이 '검증'에 서명키가 쓰임을 예고)

## 사건의 핵심 원리: 서명(Signature)과 검증 과정
tbd: 서명이 Header, Payload 그리고 **서버만 아는 서명키(Secret Key)**를 특정 해싱 알고리즘(예: HMACSHA256)을 통해 생성되는 과정을 도식화와 함께 설명
tbd: 
서버가 토큰을 받음. 
Header와 Payload를 추출. 
서버가 보관하고 있는 서명키를 이용해 토큰의 Header, Payload로 **새로운 서명(시그니처)**을 직접 생성.
새로 만든 서명과 토큰에 담겨있던 서명을 비교하여 일치하면 토큰을 신뢰.

    쿠팡 사태가 가능했던 이유: '퇴사한 관리자가 서버와 동일한 서명키를 가지고 있었기 때문에, 서버가 완벽하게 유효하다고 판단하는 위조 토큰을 만들 수 있었다.'고 결론

# 직접 실습으로 이해하는 JWT 인증 플로우
tbd: 직접 Spring Boot (JWT 라이브러리 활용) 를 만들어서 실습해보기, 클라이언트는 안드로이드로 할지 고민..

# 마무리: 서명키 관리와 JWT 보안 강화 대책
tbd: JWT의 Payload 암호화보다 서명키 관리가 훨씬 중요함을 다시 한번 강조
tbd: 핵심 보안 유의점
서명키 보안: 서명키는 절대 외부에 노출되어서는 안 되며, 정기적인 키 교체(Rotation)가 필수적임. (Ex. 퇴사 시점의 키 무효화)

내부자 통제: 핵심 서명키에 접근 가능한 인원을 최소화하고, 접근 기록을 엄격히 관리해야 함.

JWT 활용 시 주의점:
    민감 정보는 Payload에 넣지 않기 (Payload는 인코딩일 뿐 암호화가 아님).
    탈취 위험을 줄이기 위해 토큰의 유효 기간(Expiry)을 짧게 설정하고, Refresh Token 활용 방안을 소개.
    Blacklist 기능을 구현하여 유출/악용된 토큰을 강제로 무효화하는 방법 (Stateful하게 관리하는 트레이드오프 언급).