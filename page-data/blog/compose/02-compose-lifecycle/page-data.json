{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/compose/02-compose-lifecycle/","result":{"data":{"site":{"siteMetadata":{"title":"NiNyYoon"}},"markdownRemark":{"id":"b4b9eeb9-58b1-59b9-9bcf-da8873f661a5","excerpt":"Compose 수명주기 이해하기 참고: https://developer.android.com/develop/ui/compose/lifecycle?hl=ko 핵심 내용 컴포저블의 수명 주기 3단계 호출 사이트 (Call Site…","html":"<h1 id=\"compose-수명주기-이해하기\" style=\"position:relative;\"><a href=\"#compose-%EC%88%98%EB%AA%85%EC%A3%BC%EA%B8%B0-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0\" aria-label=\"compose 수명주기 이해하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Compose 수명주기 이해하기</h1>\n<p>참고: <a href=\"https://developer.android.com/develop/ui/compose/lifecycle?hl=ko\">https://developer.android.com/develop/ui/compose/lifecycle?hl=ko</a></p>\n<h2 id=\"핵심-내용\" style=\"position:relative;\"><a href=\"#%ED%95%B5%EC%8B%AC-%EB%82%B4%EC%9A%A9\" aria-label=\"핵심 내용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>핵심 내용</h2>\n<ol>\n<li>컴포저블의 수명 주기 3단계</li>\n<li>호출 사이트 (Call Site)를 통한 컴포저블 식별</li>\n<li>컴포저블 인스턴스 식별 및 리컴포지션 최적화 원리</li>\n</ol>\n<h2 id=\"0-수명주기-개요\" style=\"position:relative;\"><a href=\"#0-%EC%88%98%EB%AA%85%EC%A3%BC%EA%B8%B0-%EA%B0%9C%EC%9A%94\" aria-label=\"0 수명주기 개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>0. 수명주기 개요</h2>\n<h6 id=\"컴포지션composition-이란\" style=\"position:relative;\"><a href=\"#%EC%BB%B4%ED%8F%AC%EC%A7%80%EC%85%98composition-%EC%9D%B4%EB%9E%80\" aria-label=\"컴포지션composition 이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>컴포지션(Composition) 이란?</h6>\n<p>컴포지션은 <strong>앱의 UI를 설명하는 트리 구조</strong> 이고, 컴포지션(=UI 트리)는 컴포저블(Composable)을 실행하여 생성됩니다.<br>\nJetpack Compose 가 초기 컴포지션 시 UI를 설명하기 위해 컴포저블을 추적(tracking)합니다.<br>\n그러고 앱의 상태가 변경되면 Jetpack Compose는 리컴포지션(Recomposition)을 예약합니다.</p>\n<h6 id=\"리컴포지션recomposition이란\" style=\"position:relative;\"><a href=\"#%EB%A6%AC%EC%BB%B4%ED%8F%AC%EC%A7%80%EC%85%98recomposition%EC%9D%B4%EB%9E%80\" aria-label=\"리컴포지션recomposition이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>리컴포지션(Recomposition)이란?</h6>\n<p>상태(State) 변경에 따라 변경될 수 있는 컴포저블을 다시 실행한 다음, 모든 변경 사항을 반영하기 위해 Composition을 업데이트는 행위 입니다.</p>\n<p><strong>컴포지션은 초기 컴포지션을 통해서만 생성될 수 있으며, 리컴포지션을 통해서만 업데이트될 수 있습니다. 컴포지션을 수정하는 유일한 방법은 재구성입니다.</strong></p>\n<blockquote>\n<p>일단 개념만 간단하게 알아놓으면 되고 나중에 최적화를 고민하게 되면 Compose 단계(Composition-Layout-Drawing), 스냅샷에 대해서 배우게 될 텐데 그때 더 자세히 다루도록 합니다.</p>\n</blockquote>\n<h2 id=\"1-컴포저블의-수명-주기-3단계\" style=\"position:relative;\"><a href=\"#1-%EC%BB%B4%ED%8F%AC%EC%A0%80%EB%B8%94%EC%9D%98-%EC%88%98%EB%AA%85-%EC%A3%BC%EA%B8%B0-3%EB%8B%A8%EA%B3%84\" aria-label=\"1 컴포저블의 수명 주기 3단계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 컴포저블의 수명 주기 3단계</h2>\n<p>컴포저블은 보통 Activity, View 등과 다르게 단순하게 <strong>세 가지의 수명 주기</strong> 만을 가집니다.</p>\n<ul>\n<li>컴포지션 시간(Enter the Compositon): 컴포저블이 처음 호출되어 UI 트리에 배치됩니다.</li>\n<li>0회 이상 재구성(Recompose zero or more times): 상태 변경에 따라 컴포저블이 0번 또는 그 이상 다시 실행됩니다.</li>\n<li>컴포지션 종료(Exit the Compotion): 컴포저블이 더 이상 필요하지 않게 되어 UI 트리에 제거됩니다.</li>\n</ul>\n<p>컴포저블이 수명 주기가 더 복잡한 외부 리소스를 관리하거나 이와 상호작용해야 하는 경우 부작용(Side-effect)를 사용해야 합니다.</p>\n<h2 id=\"2-호출-사이트-call-site를-통한-컴포저블-식별\" style=\"position:relative;\"><a href=\"#2-%ED%98%B8%EC%B6%9C-%EC%82%AC%EC%9D%B4%ED%8A%B8-call-site%EB%A5%BC-%ED%86%B5%ED%95%9C-%EC%BB%B4%ED%8F%AC%EC%A0%80%EB%B8%94-%EC%8B%9D%EB%B3%84\" aria-label=\"2 호출 사이트 call site를 통한 컴포저블 식별 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 호출 사이트 (Call Site)를 통한 컴포저블 식별</h2>\n<p>그렇다면 컴포저블의 두 번째 수명 주기 단계인 <strong>'0회 이상 재구성(Recompose)'</strong> 에서 Compose가 어떤 인스턴스를 업데이트해야 할지, 혹은 건너뛰어야 할지 어떻게 알 수 있을까요?<br>\n이것을 구분하기 위해서 Compose는 각 컴포저블 호출 시 <strong>고유한 식별자</strong> 를 부여합니다.<br>\n이러한 식별자를 호출 사이트(Call site) 라고 합니다.<br>\n호출 사이트는 컴포저블이 호출되는 <strong>소스 코드의 정확한 위치</strong> 를 의미합니다.<br>\nCompose 컴파일러는 이 위치를 기준으로 컴포지션 내에서 컴포저블의 특정 인스턴스를 식별합니다.</p>\n<h2 id=\"3-컴포저블-인스턴스-식별-및-리컴포지션-최적화-원리\" style=\"position:relative;\"><a href=\"#3-%EC%BB%B4%ED%8F%AC%EC%A0%80%EB%B8%94-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EC%8B%9D%EB%B3%84-%EB%B0%8F-%EB%A6%AC%EC%BB%B4%ED%8F%AC%EC%A7%80%EC%85%98-%EC%B5%9C%EC%A0%81%ED%99%94-%EC%9B%90%EB%A6%AC\" aria-label=\"3 컴포저블 인스턴스 식별 및 리컴포지션 최적화 원리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 컴포저블 인스턴스 식별 및 리컴포지션 최적화 원리</h2>\n<p>설명했듯이, Compose는 컴포지션 내 각 컴포저블 인스턴스를 호출 사이트를 통해 고유하게 식별합니다.<br>\n이 식별 메커니즘은 단순히 UI를 생성하는 것을 넘어, 리컴포지션의 효율성을 극대화하는 핵심 원리가 됩니다.</p>\n<h3 id=\"31-인스턴스-유지와-재사용\" style=\"position:relative;\"><a href=\"#31-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EC%9C%A0%EC%A7%80%EC%99%80-%EC%9E%AC%EC%82%AC%EC%9A%A9\" aria-label=\"31 인스턴스 유지와 재사용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.1. 인스턴스 유지와 재사용</h3>\n<p>Compose는 UI 상태가 변경되어 리컴포지션이 발생할 때, 전체 UI를 처음부터 다시 그리지 않습니다. 대신, 변경이 필요한 특정 컴포저블만 선별적으로 재실행합니다.</p>\n<ul>\n<li>\n<p>호출 사이트의 역할: 상태가 변경되어 부모 컴포저블이 재실행되더라도, 자식 컴포저블의 호출 사이트가 동일하게 유지된다면, Compose는 이전에 생성된 동일한 인스턴스를 식별하고 재사용합니다.</p>\n</li>\n<li>\n<p>인스턴스의 변경: 만약 리컴포지션 시 조건문($if/else)이나 흐름 변경으로 인해 특정 컴포저블의 호출 사이트 자체가 사라지거나 새로운 위치에 호출된다면, Compose는 이전 인스턴스를 <strong>제거(Exit the Composition)</strong> 하고 새 인스턴스를 생성합니다.</p>\n</li>\n</ul>\n<h3 id=\"32-리컴포지션-건너뛰기skipping의-조건\" style=\"position:relative;\"><a href=\"#32-%EB%A6%AC%EC%BB%B4%ED%8F%AC%EC%A7%80%EC%85%98-%EA%B1%B4%EB%84%88%EB%9B%B0%EA%B8%B0skipping%EC%9D%98-%EC%A1%B0%EA%B1%B4\" aria-label=\"32 리컴포지션 건너뛰기skipping의 조건 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.2. 리컴포지션 건너뛰기(Skipping)의 조건</h3>\n<p>인스턴스를 유지하는 것만으로는 충분하지 않습니다.<br>\nCompose는 성능을 위해 해당 인스턴스 실행 자체를 건너뛰어(Skip) 실행 비용을 0으로 만들려고 시도합니다.</p>\n<p>Compose가 컴포저블의 재실행을 건너뛰는 조건은 매우 명확합니다.</p>\n<ol>\n<li>\n<p>호출 사이트가 유지되어야 합니다. (인스턴스가 재사용될 수 있어야 함)</p>\n</li>\n<li>\n<p>해당 컴포저블이 받는 <strong>모든 입력(매개변수)</strong> 이 <strong>안정적(Stable)</strong> 이어야 합니다.</p>\n</li>\n<li>\n<p>입력 매개변수들의 값이 이전 호출과 비교했을 때 변경되지 않았어야 합니다. (비교는 주로 equals() 메서드를 사용합니다.)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> 📝 참고: 안정적인 유형(Stable Type)이란?  \n 컴포즈에게 \"이 데이터는 한 번 생성되면 내용이 바뀌지 않거나,  \n 만약 내용이 바뀌면 시스템에 확실히 알려줄 수 있다\"고 약속하는 유형입니다.  \n 원시 타입(Int, String 등), 불변(Immutable) 클래스,  \n 그리고 MutableState&lt;T> 등이 안정적인 유형으로 간주됩니다.  \n 안정적이지 않은(Unstable) 타입은 값이 바뀌지 않았더라도  \n 리컴포지션을 건너뛸 수 없게 만듭니다.</code></pre></div>\n</li>\n</ol>\n<h3 id=\"33-key-컴포저블-동일-호출-사이트에서의-식별\" style=\"position:relative;\"><a href=\"#33-key-%EC%BB%B4%ED%8F%AC%EC%A0%80%EB%B8%94-%EB%8F%99%EC%9D%BC-%ED%98%B8%EC%B6%9C-%EC%82%AC%EC%9D%B4%ED%8A%B8%EC%97%90%EC%84%9C%EC%9D%98-%EC%8B%9D%EB%B3%84\" aria-label=\"33 key 컴포저블 동일 호출 사이트에서의 식별 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.3. Key 컴포저블: 동일 호출 사이트에서의 식별</h3>\n<p>일반적으로 호출 사이트가 다르면 인스턴스도 다르게 식별되지만,\n<code class=\"language-text\">for</code> 루프나 목록처럼 하나의 호출 사이트 내에서 동일한 컴포저블이 여러 번 반복되어 호출되는 경우가 있습니다.</p>\n<p>이때는 <strong>호출 순서(Execution Order)</strong> 가 인스턴스 식별에 사용됩니다.\n하지만 목록에서 항목을 추가/삭제/재정렬하면 호출 순서가 바뀌게 되고,\n이는 불필요한 리컴포지션이나 내부 상태가 꼬이는 버그를 유발할 수 있습니다.</p>\n<p>아래 코드 예제를 보면</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> test <span class=\"token operator\">=</span> remember <span class=\"token punctuation\">{</span> <span class=\"token function\">mutableStateListOf</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"가\"</span></span><span class=\"token punctuation\">,</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"나\"</span></span><span class=\"token punctuation\">,</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"다\"</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n<span class=\"token function\">Column</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">Button</span><span class=\"token punctuation\">(</span>onClick <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n        Log<span class=\"token punctuation\">.</span><span class=\"token function\">d</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Woody\"</span></span><span class=\"token punctuation\">,</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"Click Me\"</span></span><span class=\"token punctuation\">)</span>\n        test<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"라\"</span></span><span class=\"token punctuation\">)</span>\n        <span class=\"token comment\">// test.add(4) 일 때는 4에 대한 컴포저블 인스턴스만 생성됨</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">Text</span><span class=\"token punctuation\">(</span>text <span class=\"token operator\">=</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"Click Me\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    test<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span> <span class=\"token punctuation\">{</span> text <span class=\"token operator\">-></span>\n        <span class=\"token function\">NumberText</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Initial composition with text: 가\nInitial composition with text: 나\nInitial composition with text: 다\nClick Me\nRecomposition with text: 라\nRecomposition with text: 가\nRecomposition with text: 나\nInitial composition with text: 다</code></pre></div>\n<p>Index 0 에 \"라\" 를 추가했을 때<br>\n4 번째 컴포저블에 \"다\" 라는 상태를 가진 컴포저블 인스턴스가 다시 생성되는 것을 볼 수 있습니다.\n기존 \"가\", \"나\", \"다\" 에 대해 recompose 가 호출되고\n상태가 \"라\", \"가\", \"나\" 로 변경 되었습니다.</p>\n<p>이러한 동작은 개발자는 첫 번째 컴포저블이 생성되기를 기대하지만 기대와 다르게 동작합니다.<br>\n이를 해결하기 위해서는 key 를 이용해서 추가적인 정보를 알려줘야합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\">test<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span> <span class=\"token punctuation\">{</span> text <span class=\"token operator\">-></span>\n    <span class=\"token function\">key</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">NumberText</span><span class=\"token punctuation\">(</span>text <span class=\"token operator\">=</span> text<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Initial composition with text: 가\nInitial composition with text: 나\nInitial composition with text: 다\nClick Me\nInitial composition with text: 라</code></pre></div>\n<p>이렇게 key 를 이용해서 컴포저블 인스턴스에 호츨 사이트 외에 추가적인 식별자(id) 를 주게되면 기대한 바와같이 추가된 \"라\" 에 대해서만 컴포저블 인스턴스가 생성됩니다.</p>\n<p>직접 한번 돌려보면서 이해해 보기를 바랍니다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마치며</h2>\n<p>위에 제시된 for 루프와 key() 컴포저블의 사용 예시는 '컴포저블 인스턴스 식별' 메커니즘을 명확히 설명하기 위한 목적입니다.<br>\n실제 대규모 리스트 UI를 개발할 때는 성능이 최적화된 <strong>LazyColumn</strong>이나 <strong>LazyRow</strong>를 사용해야 합니다.<br>\nLazy Composable 역시 내부적으로 동일한 key 메커니즘을 활용하여 인스턴스를 효율적으로 관리하므로,<br>\n이 원리를 이해하여 Lazy List의 성능 최적화 방법을 이해하는데 도움이 되기를 바랍니다.</p>","headings":[{"depth":1,"id":"compose-수명주기-이해하기","value":"Compose 수명주기 이해하기"},{"depth":2,"id":"핵심-내용","value":"핵심 내용"},{"depth":2,"id":"0-수명주기-개요","value":"0. 수명주기 개요"},{"depth":6,"id":"컴포지션composition-이란","value":"컴포지션(Composition) 이란?"},{"depth":6,"id":"리컴포지션recomposition이란","value":"리컴포지션(Recomposition)이란?"},{"depth":2,"id":"1-컴포저블의-수명-주기-3단계","value":"1. 컴포저블의 수명 주기 3단계"},{"depth":2,"id":"2-호출-사이트-call-site를-통한-컴포저블-식별","value":"2. 호출 사이트 (Call Site)를 통한 컴포저블 식별"},{"depth":2,"id":"3-컴포저블-인스턴스-식별-및-리컴포지션-최적화-원리","value":"3. 컴포저블 인스턴스 식별 및 리컴포지션 최적화 원리"},{"depth":3,"id":"31-인스턴스-유지와-재사용","value":"3.1. 인스턴스 유지와 재사용"},{"depth":3,"id":"32-리컴포지션-건너뛰기skipping의-조건","value":"3.2. 리컴포지션 건너뛰기(Skipping)의 조건"},{"depth":3,"id":"33-key-컴포저블-동일-호출-사이트에서의-식별","value":"3.3. Key 컴포저블: 동일 호출 사이트에서의 식별"},{"depth":2,"id":"마치며","value":"마치며"}],"frontmatter":{"title":"::compose:: UI 아키텍쳐, 수명주기 이해하기","date":"October 24, 2025","description":"안드로이드 공식 사이트의 'UI 아키텍쳐, 수명주기' 를 이해하기 쉽게 정리합니다.","tags":["android","jetpack compose"],"featuredImage":null}},"previous":{"fields":{"slug":"/blog/compose/03-compose-side-effects/"},"frontmatter":{"title":"::compose:: Side-effect(부수효과) 개념"}},"next":{"fields":{"slug":"/blog/compose/01-compose-understanding/"},"frontmatter":{"title":"::compose:: 컴포즈의 이해"}}},"pageContext":{"id":"b4b9eeb9-58b1-59b9-9bcf-da8873f661a5","previousPostId":"875c2fb1-559e-5239-b803-064f21cc9dd4","nextPostId":"383554bd-032a-5380-8363-dbbc9f6ef852"}},"staticQueryHashes":["2046863741","3000541721","3274528899"],"slicesMap":{}}