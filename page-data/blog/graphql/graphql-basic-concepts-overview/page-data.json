{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/graphql/graphql-basic-concepts-overview/","result":{"data":{"site":{"siteMetadata":{"title":"NiNyYoon"}},"markdownRemark":{"id":"7e5859b7-e91e-52a1-a3f0-e452899dd9ce","excerpt":"들어가며 Gatsby로 블로그를 운영하며 GraphQL을 가볍게 접해본 후, 그 독특한 방식이 호기심이 자극되어서 깊이 있게 공부를 시작했습니다. 쿼리를 통해 필요한 데이터만 골라 가져오는 방식이 과연 REST API보다 어떤 점이 좋을지 궁금했고, 공부할수록 GraphQL…","html":"<h1 id=\"들어가며\" style=\"position:relative;\"><a href=\"#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0\" aria-label=\"들어가며 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>들어가며</h1>\n<p>Gatsby로 블로그를 운영하며 GraphQL을 가볍게 접해본 후, 그 독특한 방식이 호기심이 자극되어서 깊이 있게 공부를 시작했습니다. <strong>쿼리를 통해 필요한 데이터만 골라 가져오는 방식</strong>이 과연 REST API보다 어떤 점이 좋을지 궁금했고, 공부할수록 GraphQL은 활용성이 높은 기술이라는 것을 느꼈습니다. 이번 포스트에서는 GraphQL의 핵심 개념을 살펴보겠습니다</p>\n<h1 id=\"왜-graphql-이-탄생했을까\" style=\"position:relative;\"><a href=\"#%EC%99%9C-graphql-%EC%9D%B4-%ED%83%84%EC%83%9D%ED%96%88%EC%9D%84%EA%B9%8C\" aria-label=\"왜 graphql 이 탄생했을까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 GraphQL 이 탄생했을까?</h1>\n<p>서론에서 언급했듯이, GraphQL은 기존 <strong>REST API의 구조적 한계를 극복하기 위해 탄생</strong>했습니다. 서비스가 복잡해질수록 REST 방식은 데이터를 주고받는 과정에서 비효율성이 커지는데, 대표적으로 두 가지 문제가 발생합니다.</p>\n<ol>\n<li>\n<p><strong>오버페칭(Over-fetching)</strong>: <u>필요한 것보다 더 많이 받음</u>, 클라이언트에서 사용자의 <code class=\"language-text\">이름</code>만 필요한 상황임에도 불구하고, 서버의 엔드포인트에서 사용자의 <code class=\"language-text\">주소</code>, <code class=\"language-text\">연락처</code>, <code class=\"language-text\">가입일</code> 등 불필요한 정보까지 모두 내려받는 현상입니다. 이는 네트워크 대역폭을 낭비하고 모바일 환경에서 성능 저하의 원인이 됩니다.</p>\n</li>\n<li>\n<p><strong>언더페칭(Under-fetching)</strong>: <u>필요한 것보다 적게 받아 여러 번 요청함</u>, 하나의 화면을 구성하기 위해 <strong>여러 개의 엔드포인트를 호출</strong>해야 하는 상황입니다. 예를 들어 게시글 내용과 작성자 정보, 댓글 목록을 가져오기 위해 각각 <code class=\"language-text\">/posts</code>, <code class=\"language-text\">/users</code>, <code class=\"language-text\">/comments</code>로 세 번의 요청을 보내야 합니다. 이 과정에서 언더페칭과 더불어 각 API 응답마다 원치 않는 데이터까지 섞여 들어오는 오버페칭이 동시에 발생하기도 합니다.</p>\n</li>\n</ol>\n<br>\n<p><strong>페이스북의 고민에서 부터 시작</strong></p>\n<p>오버페칭, 언더페칭 문제는 서비스 규모가 커질수록 치명적이었습니다.<br>\n2012년 당시, 페이스북은 모바일 앱으로의 전환 과정에서 성능 문제에 직면했습니다. 뉴스피드처럼 복잡하고 다양한 데이터가 얽혀 있는 화면을 구현할 때, REST API로는 <u><strong>수많은 네트워크 요청</strong></u>과 <u><strong>데이터 낭비</strong></u>를 감당하기에는 한계가 있었습니다.</p>\n<p>그러하여 페이스북 개발팀은 <strong>\"클라이언트가 직접 필요한 데이터의 구조를 정의하고, 단 한 번의 요청으로 원하는 데이터만 받을 수 없을까?\"</strong> 라는 질문을 던졌고, 그 해답으로 GraphQL이 탄생하였습니다.</p>\n<h1 id=\"핵심-개념-알아보기\" style=\"position:relative;\"><a href=\"#%ED%95%B5%EC%8B%AC-%EA%B0%9C%EB%85%90-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0\" aria-label=\"핵심 개념 알아보기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>핵심 개념 알아보기</h1>\n<p>추상적인 개념을 알아보기 전에 어떻게 동작하는지 예를 먼저 들어보겠습니다.<br>\nGraphQL 은 클라이언트가 내가 필요한 데이터가 무엇인지 요청하면 서버에서 알려주면 서버는 그에 맞는 데이터를 돌려주는 방식이며, 이때 요청은 쿼리를 사용합니다.</p>\n<p><strong>블로그 포스트의 제목과 작성자 정보 요청(Query)</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-graphql\"><code class=\"language-graphql\"><span class=\"token punctuation\">{</span>\n    <span class=\"token property-query\">post</span><span class=\"token punctuation\">(</span><span class=\"token attr-name\">id</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token property\">title</span>\n        <span class=\"token object\">author</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token property\">name</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>서버의 응답</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"data\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token property\">\"post\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token property\">\"title\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"그래프큐엘 시작하기\"</span><span class=\"token punctuation\">,</span>\n            <span class=\"token property\">\"author\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"우디\"</span> <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>예시와 같이 클라이언트가 작성한 모양 그대로 서버의 응답이 JSON 형태로 돌아옵니다.<br>\n이러한 형태가 가능하려면 클라이언트는 서버가 <em>\"post 라는 데이터를 줄 수 있다\"</em>, <em>\"id 를 입력하면 해당 id 에 대한 post 정보만 준다.\"</em>, <em>\"post 에는 title, author 정보를 줄 수 있다.\"</em> 등에 대한 정보를 알고 있다는 건데요.<br>\n이것을 가능하게 하는 것이 GraphQL 서버의 자기소개서와 같은 <strong>스키마와 타입</strong>입니다.</p>\n<h2 id=\"핵심1-스키마와-타입the-schema--types\" style=\"position:relative;\"><a href=\"#%ED%95%B5%EC%8B%AC1-%EC%8A%A4%ED%82%A4%EB%A7%88%EC%99%80-%ED%83%80%EC%9E%85the-schema--types\" aria-label=\"핵심1 스키마와 타입the schema  types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>핵심1. 스키마와 타입(The Schema &#x26; Types)</h2>\n<p>스키마(Schema)는 <strong>GrahpQL 의 설계도</strong>이며 타입(Type)으로 구성되어 입니다.</p>\n<p>먼저 타입부터 살펴보면</p>\n<h3 id=\"타입type\" style=\"position:relative;\"><a href=\"#%ED%83%80%EC%9E%85type\" aria-label=\"타입type permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>타입(Type)</h3>\n<p>타입에는 세 가지 종류가 있습니다.</p>\n<ul>\n<li><strong>스칼라 타입(Scalar Type)</strong>: 가장 기본적인 데이터 조각입니다. 아래가 기본적으로 제공해주는 GrpahQL 스칼라 타입입니다.\n<ul>\n<li>String: 글자 (예: \"우디\")</li>\n<li>Int: 정수 (예: 25)</li>\n<li>Float: 실수 (예: 4.5)</li>\n<li>Boolean: 참/거짓 (예: true)</li>\n<li>ID: 고유 식별자 (객체를 식별할 때 쓰는 특수한 값)</li>\n<li>커스텀 스칼라(Custom Scalar): 사용자가 직접 생성한 스칼라 타입(날짜(Date)처럼 기본 타입 외에 특별히 정의한 타입)</li>\n</ul>\n</li>\n<li><strong>객체 타입(Object Type)</strong>: 스칼라 타입들을 모아서 만든 '복합 데이터'입니다. 우리가 실제 서비스에서 다루는 **사용자(User)**나 <strong>포스트(Post)</strong> 같은 데이터 입니다.</li>\n<li><strong>열거형 타입(Enum types)</strong>: 미리 정의된 특정 값들의 집합 중 하나를 선택하도록 강제하는 특별한 타입입니다. 정해진 옵션 이외의 값은 허용하지 않을 때 사용합니다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-graphql\"><code class=\"language-graphql\"><span class=\"token comment\"># 포스트의 상태를 정의하는 열거형 타입</span>\n<span class=\"token keyword\">enum</span> <span class=\"token class-name\">PostStatus</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token constant\">DRAFT</span>      <span class=\"token comment\"># 초안</span>\n    <span class=\"token constant\">PUBLISHED</span>  <span class=\"token comment\"># 발행됨</span>\n    <span class=\"token constant\">HIDDEN</span>     <span class=\"token comment\"># 숨김</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Post</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token attr-name\">id</span><span class=\"token punctuation\">:</span> <span class=\"token scalar\">ID</span>\n    <span class=\"token attr-name\">title</span><span class=\"token punctuation\">:</span> <span class=\"token scalar\">String</span>    <span class=\"token comment\"># 스칼라 타입</span>\n    <span class=\"token attr-name\">content</span><span class=\"token punctuation\">:</span> <span class=\"token scalar\">String</span>  <span class=\"token comment\"># 스칼라 타입</span>\n    <span class=\"token attr-name\">author</span><span class=\"token punctuation\">:</span> <span class=\"token class-name\">User</span>     <span class=\"token comment\"># 다른 객체 타입과의 관계</span>\n    <span class=\"token attr-name\">status</span><span class=\"token punctuation\">:</span> <span class=\"token class-name\">PostStatus</span> <span class=\"token comment\"># 열거형 타입을 필드로 사용</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>느낌표(!)를 통한 널 허용/비허용</strong></p>\n<p>타입 뒤에 붙는 느낌표(!)는 <strong>\"이 값은 절대 비어있을 수 없다(Null이 될 수 없다)\"</strong> 는 약속입니다.</p>\n<ul>\n<li>String: 이름이 없을 수도 있음 (Null 허용)</li>\n<li>String!: 이름이 무조건 있어야 함 (Null 비허용)</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-graphql\"><code class=\"language-graphql\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Post</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token attr-name\">id</span><span class=\"token punctuation\">:</span> <span class=\"token scalar\">ID</span><span class=\"token operator\">!</span>         <span class=\"token comment\"># ID는 무조건 있어야 합니다.</span>\n    <span class=\"token attr-name\">title</span><span class=\"token punctuation\">:</span> <span class=\"token scalar\">String</span><span class=\"token operator\">!</span>  <span class=\"token comment\"># 제목 없는 포스트는 존재할 수 없습니다.</span>\n    <span class=\"token attr-name\">content</span><span class=\"token punctuation\">:</span> <span class=\"token scalar\">String</span> <span class=\"token comment\"># 본문은 비어있을 수도 있습니다.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이렇게 느낌표 하나로 데이터의 필수 여부를 명확하게 정할 수 있어, 스키마 레벨에서 데이터의 <strong>무결성을 강제</strong>하고 클라이언트의 <strong>런타임 에러를 사전</strong>에 방지합니다.</p>\n<h3 id=\"스키마schema\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%82%A4%EB%A7%88schema\" aria-label=\"스키마schema permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스키마(Schema)</h3>\n<p>스키마는 위에서 만든 타입들을 한데 모으고, 클라이언트가 <strong>어떤 행동(읽기, 쓰기 등)</strong> 을 할 수 있는지 정의한 최종 문서입니다.<br>\n스키마를 보면 이 서비스의 모든 것을 알 수 있습니다.</p>\n<p>실제 스키마 파일은 보통 이런 식으로 구성됩니다. 마치 메뉴판의 '전체 카테고리'를 정해주는 것과 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-graphql\"><code class=\"language-graphql\"><span class=\"token comment\"># 1. 데이터 타입 정의</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Post</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token attr-name\">id</span><span class=\"token punctuation\">:</span> <span class=\"token scalar\">ID</span>\n  <span class=\"token attr-name\">title</span><span class=\"token punctuation\">:</span> <span class=\"token scalar\">String</span>\n  <span class=\"token attr-name\">author</span><span class=\"token punctuation\">:</span> <span class=\"token class-name\">User</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">User</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token attr-name\">id</span><span class=\"token punctuation\">:</span> <span class=\"token scalar\">ID</span>\n  <span class=\"token attr-name\">name</span><span class=\"token punctuation\">:</span> <span class=\"token scalar\">String</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\"># 2. 할 수 있는 행동(Query, Mutation 등) 정의</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Query</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\"># \"id를 주면 Post 하나를 줄게\" 라는 약속</span>\n  <span class=\"token attr-name\">post</span><span class=\"token punctuation\">(</span><span class=\"token attr-name\">id</span><span class=\"token punctuation\">:</span> <span class=\"token scalar\">ID</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token class-name\">Post</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Mutation</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\"># \"제목을 주면 새로운 포스트를 만들고 그 결과를 보여줄게\" 라는 약속</span>\n  <span class=\"token attr-name\">createPost</span><span class=\"token punctuation\">(</span><span class=\"token attr-name\">title</span><span class=\"token punctuation\">:</span> <span class=\"token scalar\">String</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token class-name\">Post</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>요약하자면 스키마는 <strong>\"어떤 타입의 데이터를(Type), 어떤 방식으로(Query/Mutation) 주고받을 것인가\"</strong> 에 대한 서버와 클라이언트의 표준이라고 할 수 있습니다.<br>\n마치 REST API 에서 API 명세서(API Specification)를 정의한 것과 같습니다.</p>\n<h3 id=\"스키마타입-작성의-장점\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%82%A4%EB%A7%88%ED%83%80%EC%9E%85-%EC%9E%91%EC%84%B1%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-label=\"스키마타입 작성의 장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스키마&#x26;타입 작성의 장점</h3>\n<ul>\n<li><strong>안정성</strong>: 정의되지 않은 엉뚱한 데이터를 요청하면 서버가 실행되기도 전에 \"그건 없는 데이터야\"라고 알려줄 수 있습니다.</li>\n<li><strong>협업 효율</strong>: 프론트엔드 개발자는 스키마만 보고도 서버 개발자에게 물어볼 필요 없이 어떤 데이터를 받아올지 알 수 있습니다.</li>\n</ul>\n<p>이제 스키마와 타입이 준비되었습니다. 그럼 이 스키마를 보고 실제로 데이터를 요청하는 방법인 **쿼리(Query)**에 대해 알아보겠습니다.</p>\n<h2 id=\"핵심2-쿼리query---데이터-읽기\" style=\"position:relative;\"><a href=\"#%ED%95%B5%EC%8B%AC2-%EC%BF%BC%EB%A6%ACquery---%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%9D%BD%EA%B8%B0\" aria-label=\"핵심2 쿼리query   데이터 읽기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>핵심2. 쿼리(Query) - 데이터 읽기</h2>\n<p>쿼리는 클라이언트가 서버에 데이터를 요청하는 방식입니다. REST API의 GET 요청과 비슷하지만, 훨씬 더 효율적입니다.</p>\n<p>REST API는 서버가 정해준 데이터를 통째로 받아야 했지만, GraphQL 쿼리는 <strong>내가 필요한 필드(Field)</strong> 만 적어서 보냅니다.<br>\n만약 블로그 포스트 <code class=\"language-text\">id:1</code> 의 제목, 작성자 이름을 가져오고 싶으면</p>\n<ul>\n<li>REST API: /posts/1 호출 시 제목, 본문, 작성일, 댓글 등 모든 데이터를 다 줍니다. (Overfetching)</li>\n<li>GraphQL: \"제목이랑 작성자 이름만 줘!\"라고 요청하면 딱 그 데이터만 줍니다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-graphql\"><code class=\"language-graphql\"><span class=\"token comment\"># \"포스트 1번의 제목(title)과 작성자 이름(name)만 필요해\"</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token property-query\">post</span><span class=\"token punctuation\">(</span><span class=\"token attr-name\">id</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token property\">title</span>\n        <span class=\"token object\">author</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token property\">name</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위와 같이 스키마만 알면 어떤 데이터를 가져올지는 <strong>클라이언트에게 주도권(Client-driven)'</strong> 이 있습니다.</p>\n<br>\n<h3 id=\"프래그먼트fragment---쿼리의-재사용\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%9E%98%EA%B7%B8%EB%A8%BC%ED%8A%B8fragment---%EC%BF%BC%EB%A6%AC%EC%9D%98-%EC%9E%AC%EC%82%AC%EC%9A%A9\" aria-label=\"프래그먼트fragment   쿼리의 재사용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프래그먼트(Fragment) - 쿼리의 재사용</h3>\n<p>쿼리를 작성하다 보면 여러 곳에서 공통된 필드들을 반복해서 적어야 할 때가 있습니다. 이때 <strong>프래그먼트</strong>를 사용하면 <b><u>중복되는 필드 세트를 하나로 묶어 재사용</u></b>할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-graphql\"><code class=\"language-graphql\"><span class=\"token comment\"># 공통 필드를 프래그먼트로 정의</span>\n<span class=\"token keyword\">fragment</span> <span class=\"token fragment function\">PostDetails</span> <span class=\"token keyword\">on</span> <span class=\"token class-name\">Post</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">id</span>\n    <span class=\"token property\">title</span>\n    <span class=\"token property\">content</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-graphql\"><code class=\"language-graphql\"><span class=\"token comment\"># 쿼리에서 사용</span>\n<span class=\"token punctuation\">{</span> \n    <span class=\"token property-query\">post</span><span class=\"token punctuation\">(</span><span class=\"token attr-name\">id</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n         <span class=\"token operator\">...</span><span class=\"token fragment function\">PostDetails</span> \n    <span class=\"token punctuation\">}</span> \n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>마치 레고 블록을 미리 조립해두고 필요할 때마다 끼워 쓰는 것과 같아 코드가 훨씬 간결해집니다.</p>\n<h2 id=\"핵심3-뮤테이션mutation---데이터-수정\" style=\"position:relative;\"><a href=\"#%ED%95%B5%EC%8B%AC3-%EB%AE%A4%ED%85%8C%EC%9D%B4%EC%85%98mutation---%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%88%98%EC%A0%95\" aria-label=\"핵심3 뮤테이션mutation   데이터 수정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>핵심3. 뮤테이션(Mutation) - 데이터 수정</h2>\n<p>뮤테이션은 REST API의 POST, PUT, DELETE를 하나로 합쳐놓은 것이라고 생각하면 쉽습니다.<br>\n쿼리가 데이터를 가져오는 '읽기' 전용이라면, **뮤테이션(Mutation)**은 서버의 데이터를 변경하는 '쓰기' 전용 통로입니다. 이름 그대로 데이터에 '변화(Mutation)'를 주는 작업이죠.</p>\n<h3 id=\"cud생성-수정-삭제-작업-처리\" style=\"position:relative;\"><a href=\"#cud%EC%83%9D%EC%84%B1-%EC%88%98%EC%A0%95-%EC%82%AD%EC%A0%9C-%EC%9E%91%EC%97%85-%EC%B2%98%EB%A6%AC\" aria-label=\"cud생성 수정 삭제 작업 처리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CUD(생성, 수정, 삭제) 작업 처리</h3>\n<p>뮤테이션을 사용하면 새로운 포스트를 만들거나(Create), 기존 내용을 고치거나(Update), 마음에 안 드는 데이터를 지우는(Delete) 작업을 할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-graphql\"><code class=\"language-graphql\"><span class=\"token comment\"># 새로운 포스트를 작성하는 Mutation 예시</span>\n<span class=\"token keyword\">mutation</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property-query property-mutation\">createPost</span><span class=\"token punctuation\">(</span><span class=\"token attr-name\">title</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"뮤테이션 배우기\"</span><span class=\"token punctuation\">,</span> <span class=\"token attr-name\">content</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"생각보다 쉬워요\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token property\">id</span>\n        <span class=\"token property\">title</span>\n        <span class=\"token property\">createdAt</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 코드는 createPost 로 title, content를 인자로 전달하고, 작업 성공 시 id, title, createdAt 필드를 받도록 요청하는 예시입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"data\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token property\">\"createPost\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token property\">\"id\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"101\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"title\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"뮤테이션 배우기\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"createdAt\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"2026-01-15T10:00:00Z\"</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"인풋-타입input-type---뮤테이션의-인자를-편하게\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%ED%92%8B-%ED%83%80%EC%9E%85input-type---%EB%AE%A4%ED%85%8C%EC%9D%B4%EC%85%98%EC%9D%98-%EC%9D%B8%EC%9E%90%EB%A5%BC-%ED%8E%B8%ED%95%98%EA%B2%8C\" aria-label=\"인풋 타입input type   뮤테이션의 인자를 편하게 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인풋 타입(input type) - 뮤테이션의 인자를 편하게</h3>\n<p>뮤테이션을 사용할 때 보낼 데이터가 많아지면(예: 제목, 본문, 카테고리, 태그 등) 인자가 너무 길어져서 가독성이 떨어집니다. 이때 관련된 인자들을 하나로 묶어주는 것이 바로 input 타입입니다.</p>\n<ul>\n<li>깔끔한 코드: 여러 개의 인자를 하나하나 나열하지 않고, '가방'에 담아 한 번에 전달하는 것과 같습니다.</li>\n<li>재사용성: 데이터를 생성할 때와 수정할 때 똑같은 input 구조를 재사용할 수 있어 편리합니다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-graphql\"><code class=\"language-graphql\"><span class=\"token comment\"># 1. input 타입 정의</span>\n<span class=\"token keyword\">input</span> <span class=\"token atom-input class-name\">CreatePostInput</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token attr-name\">title</span><span class=\"token punctuation\">:</span> <span class=\"token scalar\">String</span><span class=\"token operator\">!</span>\n  <span class=\"token attr-name\">content</span><span class=\"token punctuation\">:</span> <span class=\"token scalar\">String</span><span class=\"token operator\">!</span>\n  <span class=\"token attr-name\">category</span><span class=\"token punctuation\">:</span> <span class=\"token scalar\">String</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\"># 2. 뮤테이션에서 사용</span>\n<span class=\"token keyword\">mutation</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token property-query property-mutation\">createPost</span><span class=\"token punctuation\">(</span><span class=\"token attr-name\">input</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token attr-name\">title</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"안녕\"</span><span class=\"token punctuation\">,</span> <span class=\"token attr-name\">content</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"반가워\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">id</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"일반-타입type-vs-인풋-타입input\" style=\"position:relative;\"><a href=\"#%EC%9D%BC%EB%B0%98-%ED%83%80%EC%9E%85type-vs-%EC%9D%B8%ED%92%8B-%ED%83%80%EC%9E%85input\" aria-label=\"일반 타입type vs 인풋 타입input permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>일반 타입(Type) vs 인풋 타입(Input)</h3>\n<p>겉모습은 비슷하지만 용도가 엄격히 구분됩니다.</p>\n<ul>\n<li>객체 타입 (Object Type): 서버가 클라이언트에게 데이터를 보낼 때 사용하는 '출력용' 규격입니다.</li>\n<li>인풋 타입 (Input Type): 클라이언트가 서버에 데이터를 보낼 때 사용하는 '입력용' 규격입니다.</li>\n</ul>\n<p><strong>참고</strong>: GraphQL에서는 보안과 구조상의 이유로 일반 객체 타입을 뮤테이션의 인자로 직접 사용할 수 없게 설계되어 있습니다. 그래서 꼭 input 키워드를 사용해야 합니다.</p>\n<h2 id=\"핵심-4-서브스크립션-subscription---실시간-데이터\" style=\"position:relative;\"><a href=\"#%ED%95%B5%EC%8B%AC-4-%EC%84%9C%EB%B8%8C%EC%8A%A4%ED%81%AC%EB%A6%BD%EC%85%98-subscription---%EC%8B%A4%EC%8B%9C%EA%B0%84-%EB%8D%B0%EC%9D%B4%ED%84%B0\" aria-label=\"핵심 4 서브스크립션 subscription   실시간 데이터 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>핵심 4: 서브스크립션 (Subscription) - 실시간 데이터</h2>\n<p>쿼리가 '질문과 답변'이라면, 서브스크립션은 **'구독과 알림'**입니다. 클라이언트가 특정 이벤트가 발생했을 때 알려달라고 서버에 요청해두면, 서버가 실시간으로 데이터를 밀어주는(Push) 방식입니다.</p>\n<p><strong>1. 웹소켓(WebSocket) 기반의 실시간 통신</strong></p>\n<p>일반적인 HTTP 요청은 클라이언트가 먼저 말을 걸어야 응답을 받을 수 있지만, 서브스크립션은 웹소켓(WebSocket) 프로토콜을 사용합니다. 한 번 연결을 맺어두면 서버와 클라이언트가 계속 연결된 상태를 유지하며 데이터를 주고받을 수 있게 됩니다.</p>\n<p><strong>2. 어떻게 사용하나요?</strong></p>\n<p>주로 새로운 댓글이 달렸거나, 채팅 메시지가 왔을 때처럼 '특정 조건이 충족되는 순간' 데이터를 전송합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-graphql\"><code class=\"language-graphql\"><span class=\"token comment\"># \"누군가 댓글을 달면(commentAdded), 그 댓글의 본문과 작성자를 실시간으로 보내줘!\"</span>\n<span class=\"token keyword\">subscription</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property-query\">commentAdded</span><span class=\"token punctuation\">(</span><span class=\"token attr-name\">postId</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"101\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token property\">content</span>\n        <span class=\"token property\">author</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>3. 주요 특징</strong></p>\n<ul>\n<li><strong>이벤트 중심(Event-driven)</strong>: 서버에서 특정 데이터의 변화(주로 뮤테이션 발생)가 감지될 때 동작합니다.</li>\n<li><strong>지속성</strong>: 연결이 끊어지기 전까지는 클라이언트가 별도의 추가 요청을 보내지 않아도 최신 데이터를 계속 받아볼 수 있습니다.</li>\n<li><strong>활용 사례</strong>: 실시간 채팅, 주식 시황 알림, 배달 위치 추적 등 실시간성이 중요한 기능에 필수적입니다.</li>\n</ul>\n<h2 id=\"핵심5-리졸버resolver---데이터-채우기\" style=\"position:relative;\"><a href=\"#%ED%95%B5%EC%8B%AC5-%EB%A6%AC%EC%A1%B8%EB%B2%84resolver---%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%B1%84%EC%9A%B0%EA%B8%B0\" aria-label=\"핵심5 리졸버resolver   데이터 채우기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>핵심5. 리졸버(Resolver) - 데이터 채우기</h2>\n<p>스키마가 데이터의 생김새를 정의한 '설계도'라면, 그 설계도에 맞춰 실제로 데이터를 채워넣는 함수가 바로 리졸버입니다.</p>\n<p><strong>1. 리졸버란?</strong><br>\n클라이언트로부터 쿼리가 들어왔을 때, 해당 필드에 어떤 값을 돌려줄지 결정하는 실행 함수입니다. 스키마에 정의된 모든 필드는 사실 각각의 리졸버 함수를 가지고 있습니다.</p>\n<blockquote>\n<p>\"스키마는 '무엇(What)'을 줄지 약속하고, 리졸버는 그 데이터를 '어떻게(How)' 가져올지 담당합니다.\"</p>\n</blockquote>\n<p><strong>2. 데이터의 소스를 가리지 않는 유연성</strong>\n리졸버의 가장 강력한 특징은 데이터가 어디에 있든 상관없다는 점입니다. 하나의 쿼리 안에서도 여러 리졸버가 각각 다른 곳에서 데이터를 긁어와 합칠 수 있습니다.</p>\n<ul>\n<li><strong>DB</strong>: 사용자 정보는 MySQL에서 가져오고,</li>\n<li><strong>REST API</strong>: 포스트 정보는 기존 REST API에서 가져오고,</li>\n<li><strong>Third-party</strong>: 날씨 정보는 외부 기상청 API에서 가져와서 하나로 묶어줍니다.</li>\n</ul>\n<p><strong>3. 동작 예시</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 리졸버 함수의 예 (JavaScript 스타일)</span>\n<span class=\"token keyword\">const</span> resolvers <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token literal-property property\">Query</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// \"post 쿼리가 들어오면 DB에서 해당 id를 찾아줘!\"</span>\n        <span class=\"token function-variable function\">post</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">parent<span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">,</span> context</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> db<span class=\"token punctuation\">.</span>Posts<span class=\"token punctuation\">.</span><span class=\"token function\">findOne</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">id</span><span class=\"token operator\">:</span> args<span class=\"token punctuation\">.</span>id <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>4. 리졸버가 주는 이점</strong><br>\n클라이언트는 뒤에 DB가 있는지, 다른 API가 있는지 알 필요가 없습니다. 오직 GraphQL 엔드포인트 하나에만 물어보면 리졸버들이 각자의 위치에서 데이터를 모아 완벽한 하나의 응답을 만들어주기 때문입니다.</p>\n<h1 id=\"마치며\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마치며</h1>\n<p>이로써, GraphQL 의 핵심 개념들에 대해서 살펴봤습니다.<br>\n간단하게 필요한 요소들만 설명하였는데요. <strong>그래프 이론</strong>을 알고 GraphQL 을 배우면 이해하는데 더욱더 도움이 되지만, 그렇게 되면 포스팅을 하나 더 올려야되는 수준이라 설명드리지는 못 하였습니다.<br>\n앞으로 GraphQL을 계속해서 사용해야되는 상황이라면 찾아서 공부해 보시는 것을 추천드립니다.</p>\n<p>다음 포스팅 주제는 시간이 되면 Client(Android,), Server(Spring Boot) 를 사용하여 실습하는 예제를 올려보도록 하겠습니다.</p>\n<h2 id=\"graphql의-장단점-정리\" style=\"position:relative;\"><a href=\"#graphql%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90-%EC%A0%95%EB%A6%AC\" aria-label=\"graphql의 장단점 정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GraphQL의 장단점 정리</h2>\n<p>마지막으로 간단하게 <u>GraphQL의 장단점</u>을 정리해 보겠습니다.</p>\n<p><strong>장점</strong></p>\n<ul>\n<li>생산성 향상: 클라이언트가 필요한 데이터를 직접 정의하므로, API 변경을 위해 백엔드 개발자를 기다리는 시간이 획기적으로 줄어듭니다.</li>\n<li>자기 문서화(Self-documenting): 스키마 자체가 곧 완벽한 API 명세서입니다. 별도의 문서 도구 없이도 인트로스펙션 기능을 통해 실시간으로 API 구조를 확인할 수 있습니다.</li>\n<li>프론트-백엔드 의존성 분리: 서버는 데이터 소스 제공에 집중하고, 클라이언트는 화면 구성에 집중하는 진정한 의미의 관심사 분리가 가능해집니다.</li>\n</ul>\n<p><strong>단점</strong></p>\n<ul>\n<li>캐싱의 복잡성: REST API는 URL 단위로 캐싱하기 쉽지만, GraphQL은 요청마다 본문(Body)이 다르기 때문에 HTTP 캐싱을 그대로 쓰기 어렵습니다. (Apollo 등 별도 라이브러리의 도움 필요)</li>\n<li>파일 업로드: 표준 사양에 파일 업로드가 포함되어 있지 않아, 별도의 멀티파트 요청 처리가 필요합니다.</li>\n<li>초기 학습 곡선: 쿼리 언어뿐만 아니라 스키마 설계, 리졸버 구현 등 기존 REST 방식과는 다른 사고방식이 필요합니다.</li>\n</ul>\n<h2 id=\"다루지-않은-내용\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%EB%A3%A8%EC%A7%80-%EC%95%8A%EC%9D%80-%EB%82%B4%EC%9A%A9\" aria-label=\"다루지 않은 내용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다루지 않은 내용</h2>\n<ul>\n<li>인트로스펙션(introspection): 서버의 스키마, 타입을 조회하는 기능, Playground 에서 인스로스펙션 기능을 통해 스키마 정보를 실시간으로 확인하며 쿼리를 작성</li>\n<li>추상 구문 트리(AST): 쿼리가 들어오면 서버는 '추상 구문 트리(AST)'로 파싱하여 분석하고, 그 결과에 따라 적절한 리졸버 함수를 실행</li>\n</ul>\n<br>\n<br>\n<p>감사합니다.😊</p>","headings":[{"depth":1,"id":"들어가며","value":"들어가며"},{"depth":1,"id":"왜-graphql-이-탄생했을까","value":"왜 GraphQL 이 탄생했을까?"},{"depth":1,"id":"핵심-개념-알아보기","value":"핵심 개념 알아보기"},{"depth":2,"id":"핵심1-스키마와-타입the-schema--types","value":"핵심1. 스키마와 타입(The Schema & Types)"},{"depth":3,"id":"타입type","value":"타입(Type)"},{"depth":3,"id":"스키마schema","value":"스키마(Schema)"},{"depth":3,"id":"스키마타입-작성의-장점","value":"스키마&타입 작성의 장점"},{"depth":2,"id":"핵심2-쿼리query---데이터-읽기","value":"핵심2. 쿼리(Query) - 데이터 읽기"},{"depth":3,"id":"프래그먼트fragment---쿼리의-재사용","value":"프래그먼트(Fragment) - 쿼리의 재사용"},{"depth":2,"id":"핵심3-뮤테이션mutation---데이터-수정","value":"핵심3. 뮤테이션(Mutation) - 데이터 수정"},{"depth":3,"id":"cud생성-수정-삭제-작업-처리","value":"CUD(생성, 수정, 삭제) 작업 처리"},{"depth":3,"id":"인풋-타입input-type---뮤테이션의-인자를-편하게","value":"인풋 타입(input type) - 뮤테이션의 인자를 편하게"},{"depth":3,"id":"일반-타입type-vs-인풋-타입input","value":"일반 타입(Type) vs 인풋 타입(Input)"},{"depth":2,"id":"핵심-4-서브스크립션-subscription---실시간-데이터","value":"핵심 4: 서브스크립션 (Subscription) - 실시간 데이터"},{"depth":2,"id":"핵심5-리졸버resolver---데이터-채우기","value":"핵심5. 리졸버(Resolver) - 데이터 채우기"},{"depth":1,"id":"마치며","value":"마치며"},{"depth":2,"id":"graphql의-장단점-정리","value":"GraphQL의 장단점 정리"},{"depth":2,"id":"다루지-않은-내용","value":"다루지 않은 내용"}],"frontmatter":{"title":"GraphQL 기본 개념 살펴보기","date":"January 09, 2026","description":"GraphQL이 무엇이고 왜 사용하는지, 스키마와 타입, 쿼리, 뮤테이션, 리졸버 등을 다루어봅니다.","tags":["GraphQL"],"featuredImage":{"childImageSharp":null,"publicURL":"/static/feaa6efca9b33772d377f7200f53529f/graphql_featured_img_1.svg","extension":"svg"}}},"previous":null,"next":{"fields":{"slug":"/blog/compose/06-compose-jetpack-compose-navigation3-overview/"},"frontmatter":{"title":"::compose:: Navigation3 핵심개념 살펴보기"}}},"pageContext":{"id":"7e5859b7-e91e-52a1-a3f0-e452899dd9ce","previousPostId":null,"nextPostId":"294814cb-6c3f-5b15-af0e-00bc244b0daa"}},"staticQueryHashes":["2046863741","3000541721","3274528899"],"slicesMap":{}}